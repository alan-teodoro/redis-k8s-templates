---
# Redis Enterprise Cluster with Security Context
#
# This REC configuration includes security context settings
# that follow Pod Security Standards best practices.
#
# Usage:
#   kubectl apply -f 02-security-context.yaml

apiVersion: app.redislabs.com/v1
kind: RedisEnterpriseCluster
metadata:
  name: rec
  namespace: redis-enterprise
  labels:
    app: redis-enterprise
spec:
  nodes: 3
  
  redisEnterpriseNodeResources:
    limits:
      cpu: "4"
      memory: 8Gi
    requests:
      cpu: "2"
      memory: 8Gi
  
  persistentSpec:
    enabled: true
    storageClassName: "gp3"
    volumeSize: 100Gi
  
  redisEnterpriseImageSpec:
    repository: redislabs/redis
    versionTag: 8.0.6-8
  
  servicesRiggerSpec:
    databaseServiceType: ClusterIP
    serviceNaming: bdb_name
  
  username: admin@redis.com
  
  # ============================================
  # Pod Security Context
  # ============================================
  podSecurityContext:
    # Run as non-root user
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    fsGroup: 1001
    
    # Seccomp profile (Linux security feature)
    seccompProfile:
      type: RuntimeDefault
    
    # SELinux options (if using SELinux)
    # seLinuxOptions:
    #   level: "s0:c123,c456"
  
  # ============================================
  # Container Security Context
  # ============================================
  containerSecurityContext:
    # Prevent privilege escalation
    allowPrivilegeEscalation: false
    
    # Run as non-root
    runAsNonRoot: true
    runAsUser: 1001
    
    # Read-only root filesystem
    # Note: Redis Enterprise needs write access to some directories
    # Set to false or mount writable volumes
    readOnlyRootFilesystem: false
    
    # Drop all capabilities and add only required ones
    capabilities:
      drop:
        - ALL
      add:
        - NET_BIND_SERVICE  # Required for binding to ports < 1024
        # Add other capabilities only if needed:
        # - CHOWN
        # - DAC_OVERRIDE
        # - FOWNER
        # - SETGID
        # - SETUID

---
# Verification:
#
# 1. Check pod security context:
#    kubectl get pod rec-0 -n redis-enterprise -o jsonpath='{.spec.securityContext}' | jq
#
# 2. Check container security context:
#    kubectl get pod rec-0 -n redis-enterprise \
#      -o jsonpath='{.spec.containers[0].securityContext}' | jq
#
# 3. Verify pod is running as non-root:
#    kubectl exec rec-0 -n redis-enterprise -- id
#    # Should show uid=1001
#
# 4. Check capabilities:
#    kubectl exec rec-0 -n redis-enterprise -- cat /proc/1/status | grep Cap
#
# 5. Verify REC is healthy:
#    kubectl get rec rec -n redis-enterprise

---
# Troubleshooting:
#
# Issue: Pod fails to start with permission denied
# Solution:
#   - Check fsGroup matches volume permissions
#   - Verify runAsUser has access to required directories
#   - Check if readOnlyRootFilesystem needs to be false
#
# Issue: Cannot bind to port
# Solution:
#   - Add NET_BIND_SERVICE capability
#   - Or use ports >= 1024
#
# Issue: File operations fail
# Solution:
#   - Check fsGroup is set correctly
#   - Verify volume permissions
#   - May need to add CHOWN, FOWNER capabilities

---
# Best Practices:
#
# 1. Always run as non-root
#    - runAsNonRoot: true
#    - runAsUser: 1001 (or any non-root UID)
#
# 2. Drop all capabilities by default
#    - capabilities.drop: [ALL]
#    - Add only required capabilities
#
# 3. Prevent privilege escalation
#    - allowPrivilegeEscalation: false
#
# 4. Use seccomp profile
#    - seccompProfile.type: RuntimeDefault
#
# 5. Set fsGroup for volume access
#    - fsGroup: 1001
#
# 6. Use read-only root filesystem when possible
#    - readOnlyRootFilesystem: true
#    - Mount writable volumes for required directories

