---
# SecretStore for AWS Secrets Manager
#
# SecretStore defines how to access AWS Secrets Manager.
# It uses IRSA (IAM Roles for Service Accounts) for authentication.
#
# Prerequisites:
# 1. External Secrets Operator installed
# 2. IAM policy created (01-iam-policy.json)
# 3. IAM role created with trust policy for IRSA
# 4. Service account annotated with IAM role ARN
#
# Usage:
#   kubectl apply -f 02-secret-store.yaml
#
# Verify:
#   kubectl get secretstore -n redis-enterprise
#   kubectl describe secretstore aws-secrets-manager -n redis-enterprise

apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: redis-enterprise
  labels:
    app: redis-enterprise
    component: external-secrets
spec:
  provider:
    aws:
      # AWS service (Secrets Manager or Parameter Store)
      service: SecretsManager
      
      # AWS region
      # Change to your AWS region
      region: us-east-1
      
      # Authentication using IRSA (IAM Roles for Service Accounts)
      # This is the recommended approach for EKS
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets
            namespace: external-secrets-system

---
# Alternative: ClusterSecretStore (cluster-wide)
#
# Use ClusterSecretStore if you want to access secrets from multiple namespaces.
#
# apiVersion: external-secrets.io/v1beta1
# kind: ClusterSecretStore
# metadata:
#   name: aws-secrets-manager
# spec:
#   provider:
#     aws:
#       service: SecretsManager
#       region: us-east-1
#       auth:
#         jwt:
#           serviceAccountRef:
#             name: external-secrets
#             namespace: external-secrets-system

---
# Alternative: Using Access Keys (NOT RECOMMENDED)
#
# Only use this for testing. For production, use IRSA.
#
# Prerequisites:
# 1. Create IAM user with SecretsManager permissions
# 2. Generate access keys
# 3. Create Kubernetes secret with access keys:
#    kubectl create secret generic aws-credentials \
#      --from-literal=access-key-id=<ACCESS_KEY_ID> \
#      --from-literal=secret-access-key=<SECRET_ACCESS_KEY> \
#      -n redis-enterprise
#
# apiVersion: external-secrets.io/v1beta1
# kind: SecretStore
# metadata:
#   name: aws-secrets-manager
#   namespace: redis-enterprise
# spec:
#   provider:
#     aws:
#       service: SecretsManager
#       region: us-east-1
#       auth:
#         secretRef:
#           accessKeyIDSecretRef:
#             name: aws-credentials
#             key: access-key-id
#           secretAccessKeySecretRef:
#             name: aws-credentials
#             key: secret-access-key

---
# Verification Commands:
#
# 1. Check SecretStore status:
#    kubectl get secretstore -n redis-enterprise
#
# 2. Describe SecretStore:
#    kubectl describe secretstore aws-secrets-manager -n redis-enterprise
#
# 3. Check SecretStore is ready:
#    kubectl get secretstore aws-secrets-manager -n redis-enterprise \
#      -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'
#
# 4. Check External Secrets Operator logs:
#    kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets
#
# 5. Test SecretStore with a test ExternalSecret:
#    kubectl apply -f - <<EOF
#    apiVersion: external-secrets.io/v1beta1
#    kind: ExternalSecret
#    metadata:
#      name: test-secret
#      namespace: redis-enterprise
#    spec:
#      refreshInterval: 1h
#      secretStoreRef:
#        name: aws-secrets-manager
#        kind: SecretStore
#      target:
#        name: test-secret
#        creationPolicy: Owner
#      data:
#        - secretKey: password
#          remoteRef:
#            key: redis-enterprise/admin-password
#    EOF
#
#    # Check ExternalSecret status:
#    kubectl get externalsecret test-secret -n redis-enterprise
#    kubectl describe externalsecret test-secret -n redis-enterprise
#
#    # Check secret was created:
#    kubectl get secret test-secret -n redis-enterprise
#
#    # Cleanup:
#    kubectl delete externalsecret test-secret -n redis-enterprise

---
# Troubleshooting:
#
# Issue: SecretStore not ready
# Solution:
#   - Check External Secrets Operator is running:
#     kubectl get pods -n external-secrets-system
#   - Check service account annotation:
#     kubectl get sa external-secrets -n external-secrets-system -o yaml
#   - Verify IAM role exists and has correct trust policy
#   - Check ESO logs:
#     kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets
#
# Issue: Access denied errors
# Solution:
#   - Verify IAM policy includes required permissions
#   - Check IAM role trust policy allows IRSA
#   - Verify service account annotation matches IAM role ARN
#   - Check AWS region matches SecretStore spec
#
# Issue: Cannot assume role
# Solution:
#   - Verify OIDC provider is enabled on EKS cluster
#   - Check trust policy includes correct OIDC provider
#   - Verify service account name and namespace in trust policy
#   - Check IAM role ARN annotation on service account

